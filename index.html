<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dashboard Fileiras - Irrigação Sensor Único</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0; padding: 20px;
      display: flex; justify-content: center;
      background-color: #f7f7f7;
    }
    #container {
      max-width: 1200px; width: 100%;
    }
    h2 { text-align: center; color: #333; }
    .graficos-fileira {
      margin-bottom: 50px;
      text-align: center;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 8px;
      background: #fff;
      box-shadow: 0 4px 6px rgba(0,0,0,0.05);
    }
    .grafico-titulo {
      margin-bottom: 15px;
      font-size: 1.2em;
      color: #555;
    }
    .menu-periodo-container {
        display: flex;
        justify-content: center;
        gap: 30px;
        margin-bottom: 30px;
        padding: 10px;
        background: #eee;
        border-radius: 6px;
    }
    .menu-periodo {
      padding: 8px 12px;
      border-radius: 4px;
      border: 1px solid #ccc;
      font-size: 1em;
      cursor: pointer;
    }
    canvas {
      max-width: 100%;
      height: 400px !important;
      display: block;
      margin: 0 auto;
    }
  </style>
</head>
<body>
<div id="container">
  <h2>Monitoramento de Umidade por Fileira<br />Irrigação Automática • Sensor único a 20cm</h2>
  
  <div class="menu-periodo-container">
    <label for="mesSelect">Selecione o Mês:
        <select id="mesSelect" class="menu-periodo">
            <option value="novembro">Novembro</option>
            <option value="outubro">Outubro</option>
            <option value="setembro">Setembro</option>
            <option value="agosto">Agosto</option>
            <option value="julho">Julho</option>
        </select>
    </label>

    <label for="periodoSelect">Exibir período:
      <select id="periodoSelect" class="menu-periodo">
        <option value="24h">Últimas 24h</option>
        <option value="7d">1 semana</option>
        <option value="15d">15 dias</option>
        <option value="all">Todo o Mês</option>
      </select>
    </label>
  </div>
  
  <div id="graficos"></div>
</div>
<script>
const fileiras = ["fileiraA", "fileiraB", "fileiraC", "fileiraD"];
const cores = ['#007bff','#dc3545','#28a745','#ffc107']; 
const mesSelect = document.getElementById('mesSelect');
const periodoSelect = document.getElementById('periodoSelect');

// CORREÇÃO: Ajuste a URL para corresponder ao formato de arquivo enviado (ex: fileiraA_novembro_2025.log)
const getLogUrl = (fileira, mes) => {
    // Usamos o ano 2025, pois todos os logs enviados têm esse sufixo
    const ano = 2025; 
    return `./${fileira}_${mes}_${ano}.log`; 
};

let fileiraCache = {};

// Função para buscar e processar logs
async function fetchFileiraLog(url) {
  const cacheKey = url;
  if(fileiraCache[cacheKey]) return fileiraCache[cacheKey];

  try {
    const resp = await fetch(url);
    if (!resp.ok) {
        if (resp.status !== 404) {
             console.error(`Falha ao carregar log de ${url}: ${resp.status}`);
        }
        return { labels: [], umidade: [], eventos: [] };
    }
    const text = await resp.text();
    // Lida com diferentes quebras de linha (Windows, Linux)
    const linhas = text.trim().split(/\r?\n/);
    const labels = [], umidade = [], eventos = [];
    
    linhas.forEach((linha, i) => {
      // CORREÇÃO: Remove o prefixo de citação "" e o sinal "%"
      const cleanLine = linha.replace(/\\s*/, '').trim(); 
      if (cleanLine.length === 0) return;

      const partes = cleanLine.split(';');
      
      if (partes.length >= 2) {
        labels.push(partes[0].trim()); 
        
        // Remove o '%' e converte para float
        const umidadeStr = partes[1].replace('%', '').trim();
        const umidadeVal = parseFloat(umidadeStr);
        umidade.push(isNaN(umidadeVal) ? null : umidadeVal);

        // Se houver status (terceira coluna)
        if (partes.length >= 3 && partes[2]) {
          eventos.push({ x: i, status: partes[2].trim() });
        }
      }
    });
    
    fileiraCache[cacheKey] = { labels, umidade, eventos };
    return fileiraCache[cacheKey];
  } catch (e) {
    console.error(`Erro durante o fetch ou parsing do log em ${url}:`, e);
    return { labels: [], umidade: [], eventos: [] };
  }
}

function getPeriodIndices(labels, period) {
  const total = labels.length;
  // Assume 24 leituras por dia.
  if(period==='24h') return [Math.max(0,total-24), total];
  if(period==='7d') return [Math.max(0,total-24*7), total];
  if(period==='15d') return [Math.max(0,total-24*15), total];
  return [0,total]; 
}

function plotFileira(canvasId, titulo, cor, labels, umidade, eventos) {
  const ctx = document.getElementById(canvasId).getContext('2d');
  
  const umidadePlotData = labels.map((l, i) => ({ x: l, y: umidade[i] }));

  // Filtra e mapeia os eventos para o scatter plot
  const eventData_ON = eventos
      .filter(e => e.status === 'RELE_ON' && umidade[e.x] !== null)
      .map(e => ({ x: labels[e.x], y: umidade[e.x] }));
      
  const eventData_OFF = eventos
      .filter(e => e.status === 'RELE_OFF' && umidade[e.x] !== null)
      .map(e => ({ x: labels[e.x], y: umidade[e.x] }));
  
  const existingChart = Chart.getChart(canvasId);
  if (existingChart) existingChart.destroy();
  
  new Chart(ctx, {
    type: 'line',
    data: {
      labels: labels, 
      datasets: [
        {
          label: 'Umidade (%)',
          data: umidadePlotData, 
          borderColor: cor,
          backgroundColor: cor,
          pointRadius: 1, 
          fill: false,
          tension: 0.1,
          parsing: false // Para usar nosso próprio mapeamento {x, y}
        },
        {
          type: 'scatter',
          label: 'RELE_ON (Irrigando)',
          data: eventData_ON,
          borderColor: 'black',
          backgroundColor: 'red',
          pointRadius: 6,
          pointStyle: 'triangle',
          showLine: false,
        },
        {
          type: 'scatter',
          label: 'RELE_OFF (Parado)',
          data: eventData_OFF,
          borderColor: 'black',
          backgroundColor: 'green',
          pointStyle: 'rectRot',
          pointRadius: 4,
          showLine: false,
        }
      ]
    },
    options: {
      plugins: { 
          legend: { display: true },
          tooltip: {
              callbacks: {
                  label: function(context) {
                      let label = context.dataset.label || '';
                      if (label) {
                          label += ': ';
                      }
                      if (context.raw.y !== null) {
                          label += context.raw.y + '%';
                      }
                      return label;
                  },
                  title: function(context) {
                      return context[0].parsed.x;
                  }
              }
          }
      },
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { 
            type: 'category', 
            title: { display: true, text: 'Data/Hora' }, 
            ticks: { 
                maxRotation: 60, 
                minRotation: 45, 
                maxTicksLimit: 12,
                callback: function(value, index, values) {
                    return index % Math.ceil(labels.length / 12) === 0 ? value : ''; 
                }
            } 
        },
        y: { 
            beginAtZero: true, 
            max: 40, 
            title: { display: true, text: 'Umidade (%)' } 
        }
      }
    }
  });
}

async function desenhaGraficos() {
  const mes = mesSelect.value;
  const periodo = periodoSelect.value;
  const container = document.getElementById('graficos');
  container.innerHTML = '<p style="text-align: center; color: #555;">Carregando dados...</p>';
  
  let hasData = false;
  
  // Destroi todos os gráficos (método mais seguro)
  container.innerHTML = ''; 

  for(let i=0; i<fileiras.length; i++) {
    const fileira = fileiras[i];
    const url = getLogUrl(fileira, mes);
    
    const data = await fetchFileiraLog(url);

    // Cria a div do gráfico (mesmo se sem dados, para feedback)
    const titulo = `${fileira.charAt(0).toUpperCase() + fileira.slice(1)} - ${mes.charAt(0).toUpperCase() + mes.slice(1)}`;
    const canvasId = `canvas_${fileira}_${mes}`;
    const div = document.createElement('div');
    div.className = 'graficos-fileira';

    if(data.labels.length > 0) {
        hasData = true;
        
        let [ini, fim] = getPeriodIndices(data.labels, periodo);
        
        const labelsRecorte = data.labels.slice(ini, fim);
        const umidadeRecorte = data.umidade.slice(ini, fim);
        
        const eventosRecorte = data.eventos
                                   .filter(ev => ev.x >= ini && ev.x < fim)
                                   .map(ev => ({x: ev.x - ini, status: ev.status})); 

        div.innerHTML = `<div class="grafico-titulo"><b>${titulo}</b></div>
<canvas id="${canvasId}" height="400"></canvas>`;
        container.appendChild(div);
        
        plotFileira(canvasId, titulo, cores[i], labelsRecorte, umidadeRecorte, eventosRecorte);
    } else {
        // Exibe mensagem de erro se o arquivo não for encontrado/vazio.
        div.innerHTML = `<div class="grafico-titulo"><b>${titulo}</b></div><p style="color: #dc3545; text-align: center;">Arquivo de log não encontrado ou vazio: ${url.split('./')[1]}</p>`;
        container.appendChild(div);
    }
  }

  if (!hasData) {
     container.innerHTML = '<p style="color: red; text-align: center;">Nenhum dado encontrado para as fileiras selecionadas. Verifique se os arquivos de log estão na pasta correta.</p>';
  }
}

// Event Listeners
mesSelect.addEventListener('change', function(){
  desenhaGraficos();
});

periodoSelect.addEventListener('change', function(){
  desenhaGraficos();
});

document.addEventListener('DOMContentLoaded', function() {
    desenhaGraficos();
});
</script>
</body>
</html>