<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dashboard Fileiras - Irrigação Sensor Único</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0; padding: 20px;
      display: flex; justify-content: center;
    }
    #container {
      max-width: 1200px; width: 100%;
    }
    h2 { text-align: center; }
    .graficos-fileira {
      margin-bottom: 50px;
      text-align: center;
    }
    .grafico-titulo {
      margin-bottom: 8px;
    }
    .menu-periodo {
      width: 200px; margin: 10px auto 25px auto; display:block;
    }
    canvas {
      width: 70vw !important;
      max-width: 70vw !important;
      min-width: 400px;
      height: 400px !important;
      min-height: 400px !important;
      display: block;
      margin: 0 auto 30px;
      background: #fff;
      border-radius: 6px;
      box-shadow: 0 2px 8px rgba(150,150,150,0.08);
    }
  </style>
</head>
<body>
<div id="container">
  <h2>Monitoramento de Umidade por Fileira<br />Irrigação Automática • Sensor único a 20cm</h2>
  <label for="periodo" class="menu-periodo">Exibir período:
    <select id="periodo" class="menu-periodo">
      <option value="24h">Últimas 24h</option>
      <option value="7d">1 semana</option>
      <option value="15d">15 dias</option>
      <option value="1m">1 mês</option>
      <option value="all">Todos</option>
    </select>
  </label>
  <div id="graficos"></div>
</div>
<script>
const fileiras = ["fileiraA", "fileiraB", "fileiraC", "fileiraD"];
const cores = ['blue','red','green','orange'];
// NOTA: As URLs originais apontam para o GitHub. Se estiver rodando localmente,
// você deve alterar isso para caminhos relativos, por exemplo: `./fileiraA.log`
const urls = fileiras.map(f => 
  `https://raw.githubusercontent.com/Rilen/IrrigaSeca/main/data/${f}.log`
);

// CORREÇÃO: Função para buscar e processar logs
async function fetchFileiraLog(url) {
  try {
    const resp = await fetch(url);
    if (!resp.ok) {
        console.error(`Falha ao carregar log de ${url}: ${resp.status} - Verifique se a URL está correta ou use um servidor web.`);
        return { labels: [], umidade: [], eventos: [] };
    }
    const text = await resp.text();
    // Corrigindo o split() para usar o caractere de nova linha padrão.
    const linhas = text.trim().split('\n');
    const labels = [], umidade = [], eventos = [];
    
    linhas.forEach((linha, i) => {
      // CORREÇÃO: Remove o prefixo de citação "" que estava nos logs fornecidos
      const cleanLine = linha.replace(/\\s*/, '').trim(); 
      if (cleanLine.length === 0) return; // Ignora linhas vazias

      const partes = cleanLine.split(';');
      
      // logs fileiraX.log tem pelo menos Data/Hora e Umidade
      if (partes.length >= 2) {
        // Usa a data/hora limpa para os rótulos (Chart.js fará o parsing da data/hora string)
        labels.push(partes[0].trim()); 
        
        // Garante que a umidade é um número (ou null se não for)
        const umidadeVal = parseFloat(partes[1]);
        umidade.push(isNaN(umidadeVal) ? null : umidadeVal);

        // Se houver status (terceira coluna)
        if (partes.length >= 3 && partes[2]) {
          eventos.push({ x: i, status: partes[2].trim() });
        }
      }
    });
    return { labels, umidade, eventos };
  } catch (e) {
    console.error("Erro durante o fetch ou parsing do log:", e);
    return { labels: [], umidade: [], eventos: [] };
  }
}

function getPeriodIndices(labels, period) {
  // CORREÇÃO Lógica de fatiamento: Assume-se que há uma entrada por hora (ex: 24 entradas = 24h)
  const total = labels.length;
  if(period==='24h') return [Math.max(0,total-24), total];
  if(period==='7d') return [Math.max(0,total-24*7), total];
  if(period==='15d') return [Math.max(0,total-24*15), total];
  if(period==='1m') return [Math.max(0,total-24*30), total];
  return [0,total];
}

function plotFileira(canvasId, titulo, cor, labels, umidade, eventos) {
  const ctx = document.getElementById(canvasId).getContext('2d');
  
  // Mapeia eventos para os pontos correspondentes nos dados de umidade
  const eventData_ON = eventos.filter(e => e.status === 'RELE_ON').map(e => ({ x: labels[e.x], y: umidade[e.x] }));
  const eventData_OFF = eventos.filter(e => e.status === 'RELE_OFF').map(e => ({ x: labels[e.x], y: umidade[e.x] }));

  // O Chart.js precisa de rótulos únicos para o eixo X, e se for do tipo 'linear'
  // ou 'time', o 'data' precisa ser {x: valor_do_label, y: valor_da_umidade}.
  // Como o código original usava o índice 'i' e o Chart.js está configurado
  // para 'categorical' (implícito), vamos usar um array simples de umidade
  // e o array de labels (strings) para o eixo X.
  
  // Para exibir as marcações de tempo corretamente e suportar o scatter,
  // é melhor usar o formato {x: date, y: value} para a linha de umidade também.
  
  const umidadePlotData = labels.map((l, i) => ({ x: l, y: umidade[i] }));
  
  // CORREÇÃO: Destroi o gráfico existente para evitar sobreposição (se houver)
  const existingChart = Chart.getChart(canvasId);
  if (existingChart) existingChart.destroy();
  
  new Chart(ctx, {
    type: 'line',
    data: {
      labels: labels, // Usaremos os rótulos de tempo como rótulos categóricos no eixo X
      datasets: [
        {
          label: 'Umidade (%)',
          data: umidadePlotData, // Passa os dados como {x, y} para manter a relação com o label
          borderColor: cor,
          backgroundColor: cor,
          pointRadius: 2,
          fill: false,
          tension: 0.1
        },
        {
          type: 'scatter',
          label: 'RELE_ON',
          data: eventData_ON,
          borderColor: 'black',
          backgroundColor: 'magenta',
          pointRadius: 6,
          showLine: false,
        },
        {
          type: 'scatter',
          label: 'RELE_OFF',
          data: eventData_OFF,
          borderColor: 'black',
          backgroundColor: 'lime',
          pointStyle: 'rect',
          pointRadius: 6,
          showLine: false,
        }
      ]
    },
    options: {
      plugins: { legend: { display: true } },
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { 
            // CORREÇÃO: Usar um tipo 'category' para strings de data/hora não formatadas
            type: 'category', 
            title: { display: true, text: 'Data/Hora' }, 
            ticks: { 
                maxRotation: 60, 
                minRotation: 45, 
                maxTicksLimit: 12,
                // Mostra a cada 4 ticks para evitar aglomeração
                callback: function(value, index, values) {
                    return index % 4 === 0 ? value : ''; 
                }
            } 
        },
        y: { 
            beginAtZero: true, 
            max: 40, // Mantido o max de 40%
            title: { display: true, text: 'Umidade (%)' } 
        }
      }
    }
  });
}

let fileiraCache = {};

async function desenhaGraficos(periodo) {
  const container = document.getElementById('graficos');
  container.innerHTML = 'Carregando dados...'; // Feedback de carregamento
  
  // Destruir gráficos existentes antes de desenhar novos
  fileiras.forEach(f => {
    const existingChart = Chart.getChart(`canvas_${f}`);
    if (existingChart) existingChart.destroy();
  });

  // Carrega e armazena os dados, se ainda não estiverem em cache
  for(let i=0; i<fileiras.length; i++) {
    if(!fileiraCache[fileiras[i]] || periodo === 'all') { // Recarregar para 'all' ou se não estiver em cache
      try {
        fileiraCache[fileiras[i]] = await fetchFileiraLog(urls[i]);
      } catch (e) {
        console.error(`Falha ao carregar dados da ${fileiras[i]}`);
        fileiraCache[fileiras[i]] = { labels: [], umidade: [], eventos: [] };
      }
    }
  }
  
  // Se todos os dados falharam, avisa o usuário
  if (Object.values(fileiraCache).every(d => d.labels.length === 0)) {
     container.innerHTML = '<p style="color: red; text-align: center;">Não foi possível carregar os dados de nenhuma fileira. Verifique os caminhos dos arquivos ou a conexão com a internet.</p>';
     return;
  }
  
  container.innerHTML = ''; // Limpa a mensagem de carregamento para desenhar os gráficos

  // Desenha os gráficos com os dados filtrados
  for(let i=0; i<fileiras.length; i++) {
    const data = fileiraCache[fileiras[i]];
    if(data.labels.length === 0) {
        const div = document.createElement('div');
        div.className = 'graficos-fileira';
        div.innerHTML = `<div class="grafico-titulo"><b>Fileira ${String.fromCharCode(65+i)} (Sensor 20cm)</b></div><p style="color: orange; text-align: center;">Sem dados para exibir.</p>`;
        container.appendChild(div);
        continue;
    }
    
    // Filtra os dados de acordo com o período, baseado no índice (assumindo entradas horárias)
    let [ini, fim] = getPeriodIndices(data.labels, periodo);
    
    const labelsRecorte = data.labels.slice(ini, fim);
    const umidadeRecorte = data.umidade.slice(ini, fim);
    
    // Ajustar os índices dos eventos ao novo intervalo
    const eventosRecorte = data.eventos.filter(ev => ev.x >= ini && ev.x < fim).map(ev => ({x: labelsRecorte[ev.x - ini], status: ev.status}));
    
    const titulo = `Fileira ${String.fromCharCode(65+i)} (Sensor 20cm)`;
    const canvasId = `canvas_${fileiras[i]}`;
    const div = document.createElement('div');
    div.className = 'graficos-fileira';
    div.innerHTML = `<div class="grafico-titulo"><b>${titulo}</b></div>
<canvas id="${canvasId}" height="400"></canvas>`;
    container.appendChild(div);
    
    plotFileira(canvasId, titulo, cores[i], labelsRecorte, umidadeRecorte, eventosRecorte);
  }
}

document.getElementById('periodo').addEventListener('change', function(e){
  // CORREÇÃO: Limpar o cache se o período for 'all' para recarregar todos os dados
  if (e.target.value === 'all') {
      fileiraCache = {};
  }
  desenhaGraficos(e.target.value);
});

// Inicia o desenho dos gráficos
desenhaGraficos('24h');
</script>
</body>
</html>
